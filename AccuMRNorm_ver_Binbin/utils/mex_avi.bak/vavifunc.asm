; Listing generated by Microsoft (R) Optimizing Compiler Version 12.00.9044.0 

	TITLE	vavifunc.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0DF@CHBP@?6vavifunc?4c?3?5failed?5to?5open?5the?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DE@ELLN@?6vavifunc?4c?3?5failed?5to?5open?5the?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DC@FIIE@?5vavifunc?5warning?3?5RGB565?$DP?$DP?$DP?0?5no@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT _InitAVILib
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ExitAVILib
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _FlipBGR2RGB
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _OpenAVI
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _GrabAVIFrame
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _GrabAVIFrameDouble
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _GrabAVIFrameMatlab
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _CloseAVI
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_BSS	SEGMENT
_vaviInitialized DD 01H DUP (?)
_BSS	ENDS
PUBLIC	_InitAVILib
EXTRN	_AVIFileInit@0:NEAR
; Function compile flags: /Ogt
; File vavifunc.c
;	COMDAT _InitAVILib
_TEXT	SEGMENT
_InitAVILib PROC NEAR					; COMDAT

; 47   :   // Opens The AVIFile Library.
; 48   :   if (vaviInitialized == 0) AVIFileInit();

	mov	eax, DWORD PTR _vaviInitialized
	test	eax, eax
	jne	SHORT $L53141
	call	_AVIFileInit@0
$L53141:

; 49   :   vaviInitialized = 1;

	mov	DWORD PTR _vaviInitialized, 1

; 50   : }

	ret	0
_InitAVILib ENDP
_TEXT	ENDS
PUBLIC	_ExitAVILib
EXTRN	_AVIFileExit@0:NEAR
; Function compile flags: /Ogt
;	COMDAT _ExitAVILib
_TEXT	SEGMENT
_ExitAVILib PROC NEAR					; COMDAT

; 53   : 	// Release The AVIFile Library.
; 54   :   if (vaviInitialized)  AVIFileExit();

	mov	eax, DWORD PTR _vaviInitialized
	test	eax, eax
	je	SHORT $L52978
	jmp	_AVIFileExit@0
$L52978:

; 55   : }

	ret	0
_ExitAVILib ENDP
_TEXT	ENDS
PUBLIC	_FlipBGR2RGB
; Function compile flags: /Ogt
;	COMDAT _FlipBGR2RGB
_TEXT	SEGMENT
_buffer$ = 8
_len$ = 12
_b$ = 8
_sz$ = 12
_FlipBGR2RGB PROC NEAR					; COMDAT

; 61   : {

	push	ebp
	mov	ebp, esp

; 62   : #if 0
; 63   :   int i, sz = len*3;
; 64   :   char *buf, tmpv;
; 65   : 
; 66   :   buf = (char *)buffer;
; 67   :   for (i = 0; i < sz; i+=3) {
; 68   :     tmpv = buf[i];
; 69   :     buf[i] = buf[i+2];
; 70   :     buf[i+2] = tmpv;
; 71   :   }
; 72   : 
; 73   : 
; 74   : #else
; 75   : 	void* b = buffer;						// Pointer To The Buffer

	mov	eax, DWORD PTR _buffer$[ebp]

; 76   :   int sz = len;

	mov	ecx, DWORD PTR _len$[ebp]
	push	ebx
	mov	DWORD PTR _b$[ebp], eax
	mov	DWORD PTR _sz$[ebp], ecx

; 78   : 	{
; 79   : 		mov ecx, sz					// Set Up A Counter (Dimensions Of Memory Block)

	mov	ecx, DWORD PTR _sz$[ebp]

; 80   :     mov ebx, b						// Points ebx To Our Data (b)

	mov	ebx, DWORD PTR _b$[ebp]
$label$52986:

; 81   : 		label:							// Label Used For Looping
; 82   : 			mov al,[ebx+0]					// Loads Value At ebx Into al

	mov	al, BYTE PTR [ebx]

; 83   : 			mov ah,[ebx+2]					// Loads Value At ebx+2 Into ah

	mov	ah, BYTE PTR [ebx+2]

; 84   : 			mov [ebx+2],al					// Stores Value In al At ebx+2

	mov	BYTE PTR [ebx+2], al

; 85   : 			mov [ebx+0],ah					// Stores Value In ah At ebx

	mov	BYTE PTR [ebx], ah

; 86   : 			
; 87   : 			add ebx,3					// Moves Through The Data By 3 Bytes

	add	ebx, 3

; 88   : 			dec ecx						// Decreases Our Loop Counter

	dec	ecx

; 89   : 			jnz label					// If Not Zero Jump Back To Label

	jne	SHORT $label$52986

; 77   : 	__asm								// Assembler Code To Follow

	pop	ebx

; 90   : 	}
; 91   : #endif
; 92   : }

	pop	ebp
	ret	0
_FlipBGR2RGB ENDP
_TEXT	ENDS
PUBLIC	_OpenAVI
PUBLIC	??_C@_0DF@CHBP@?6vavifunc?4c?3?5failed?5to?5open?5the?5@ ; `string'
PUBLIC	??_C@_0DE@ELLN@?6vavifunc?4c?3?5failed?5to?5open?5the?5@ ; `string'
PUBLIC	__real@3fe0000000000000
EXTRN	_AVIStreamOpenFromFileA@24:NEAR
EXTRN	__imp__GetLastError@0:NEAR
EXTRN	__fltused:NEAR
EXTRN	_mexPrintf:NEAR
EXTRN	_AVIStreamRelease@4:NEAR
EXTRN	_AVIStreamInfoA@12:NEAR
EXTRN	_AVIStreamLength@4:NEAR
EXTRN	_AVIStreamSampleToTime@8:NEAR
EXTRN	_AVIStreamGetFrameOpen@8:NEAR
;	COMDAT ??_C@_0DF@CHBP@?6vavifunc?4c?3?5failed?5to?5open?5the?5@
_DATA	SEGMENT
??_C@_0DF@CHBP@?6vavifunc?4c?3?5failed?5to?5open?5the?5@ DB 0aH, 'vavifun'
	DB	'c.c: failed to open the AVI stream. error=%d', 00H ; `string'
_DATA	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT ??_C@_0DE@ELLN@?6vavifunc?4c?3?5failed?5to?5open?5the?5@
_DATA	SEGMENT
??_C@_0DE@ELLN@?6vavifunc?4c?3?5failed?5to?5open?5the?5@ DB 0aH, 'vavifun'
	DB	'c.c: failed to open the AVI frame. error=%d', 00H ; `string'
; Function compile flags: /Ogt
_DATA	ENDS
;	COMDAT _OpenAVI
_TEXT	SEGMENT
_m$ = 8
_OpenAVI PROC NEAR					; COMDAT

; 96   : {

	push	ebp
	mov	ebp, esp
	push	esi

; 97   :   int error;
; 98   : 
; 99   : 	// Opens The AVI Stream
; 100  :   if (AVIStreamOpenFromFile(&m->pavi, m->filename, streamtypeVIDEO, 0, OF_READ, NULL)!= 0)	{

	mov	esi, DWORD PTR _m$[ebp]
	push	edi
	push	0
	push	0
	push	0
	lea	eax, DWORD PTR [esi+172]
	lea	edi, DWORD PTR [esi+164]
	push	1935960438				; 73646976H
	push	eax
	push	edi
	call	_AVIStreamOpenFromFileA@24
	test	eax, eax
	je	SHORT $L53000

; 101  :     error = GetLastError();

	call	DWORD PTR __imp__GetLastError@0

; 102  :     printf("\nvavifunc.c: failed to open the AVI stream. error=%d",error);

	push	eax
	push	OFFSET FLAT:??_C@_0DF@CHBP@?6vavifunc?4c?3?5failed?5to?5open?5the?5@ ; `string'
	call	_mexPrintf
	add	esp, 8

; 135  : 
; 136  :  on_error:
; 137  : 
; 138  :   return -1;

	or	eax, -1
	pop	edi
	pop	esi

; 139  : }

	pop	ebp
	ret	0
$L53000:

; 103  :     goto on_error;
; 104  : 	}
; 105  :   
; 106  :   // Reads Information About The Stream Into si
; 107  : 	AVIStreamInfo(m->pavi, &m->si, sizeof(AVISTREAMINFO));

	mov	edx, DWORD PTR [edi]
	lea	ecx, DWORD PTR [esi+24]
	push	140					; 0000008cH
	push	ecx
	push	edx
	call	_AVIStreamInfoA@12

; 108  :   // Width Is Right Side Of Frame Minus Left
; 109  : 	m->width = m->si.rcFrame.right - m->si.rcFrame.left;

	mov	eax, DWORD PTR [esi+84]
	mov	ecx, DWORD PTR [esi+76]

; 110  :   // Height Is Bottom Of Frame Minus Top
; 111  : 	m->height = m->si.rcFrame.bottom - m->si.rcFrame.top;

	mov	edx, DWORD PTR [esi+80]
	sub	eax, ecx
	mov	ecx, DWORD PTR [esi+88]
	mov	DWORD PTR [esi+8], eax
	sub	ecx, edx

; 112  :   // The Last Frame Of The Stream
; 113  : 	m->numframes = AVIStreamLength(m->pavi);

	mov	edx, DWORD PTR [edi]
	push	edx
	mov	DWORD PTR [esi+12], ecx
	call	_AVIStreamLength@4
	mov	DWORD PTR [esi+16], eax

; 114  :   // Calculate Rough Milliseconds Per Frame
; 115  : 	m->mpf = AVIStreamSampleToTime(m->pavi,m->numframes)/m->numframes;

	push	eax
	mov	eax, DWORD PTR [edi]
	push	eax
	call	_AVIStreamSampleToTime@8

; 116  : 
; 117  :   // get half of aspect ratio
; 118  :   m->haspect = (float)(((double)m->height)/((double)m->width/2.0));

	fild	DWORD PTR [esi+12]
	fild	DWORD PTR [esi+8]
	cdq
	idiv	DWORD PTR [esi+16]
	fmul	QWORD PTR __real@3fe0000000000000
	fdivp	ST(1), ST(0)

; 119  : 
; 120  : 
; 121  :   // Create The PGETFRAME Using Our Request Mode
; 122  : 	m->pgf = AVIStreamGetFrameOpen(m->pavi, NULL);

	mov	ecx, DWORD PTR [edi]
	push	0
	push	ecx
	mov	DWORD PTR [esi+168], eax
	fstp	DWORD PTR [esi+20]
	call	_AVIStreamGetFrameOpen@8

; 123  : 	if (m->pgf == NULL) {

	test	eax, eax
	mov	DWORD PTR [esi], eax
	jne	SHORT $L53009

; 124  :     error = GetLastError();

	call	DWORD PTR __imp__GetLastError@0

; 125  :     printf("\nvavifunc.c: failed to open the AVI frame. error=%d",error);

	push	eax
	push	OFFSET FLAT:??_C@_0DE@ELLN@?6vavifunc?4c?3?5failed?5to?5open?5the?5@ ; `string'
	call	_mexPrintf

; 126  :     AVIStreamRelease(m->pavi);      // Release The Stream

	mov	edx, DWORD PTR [edi]
	add	esp, 8
	push	edx
	call	_AVIStreamRelease@4
	pop	edi

; 135  : 
; 136  :  on_error:
; 137  : 
; 138  :   return -1;

	or	eax, -1
$on_error$53002:
	pop	esi

; 139  : }

	pop	ebp
	ret	0
$L53009:
	pop	edi

; 127  : 
; 128  :     goto on_error;
; 129  : 	}
; 130  : 
; 131  : 	// Information For The Title Bar (Width / Height / Last Frame)
; 132  : 	//printf ("\navimovie: width: %d, height: %d, frames: %d", m->width, m->height, m->numframes);
; 133  : 
; 134  :   return 0;

	xor	eax, eax
	pop	esi

; 139  : }

	pop	ebp
	ret	0
_OpenAVI ENDP
_TEXT	ENDS
PUBLIC	_GrabAVIFrame
PUBLIC	??_C@_0DC@FIIE@?5vavifunc?5warning?3?5RGB565?$DP?$DP?$DP?0?5no@ ; `string'
EXTRN	_AVIStreamGetFrame@8:NEAR
;	COMDAT ??_C@_0DC@FIIE@?5vavifunc?5warning?3?5RGB565?$DP?$DP?$DP?0?5no@
_DATA	SEGMENT
??_C@_0DC@FIIE@?5vavifunc?5warning?3?5RGB565?$DP?$DP?$DP?0?5no@ DB ' vavi'
	DB	'func warning: RGB565???, not supportted yet.', 00H ; `string'
; Function compile flags: /Ogt
_DATA	ENDS
;	COMDAT _GrabAVIFrame
_TEXT	SEGMENT
_m$ = 8
_bmpdata$ = 12
_n$ = 8
_GrabAVIFrame PROC NEAR					; COMDAT

; 144  : {

	push	ebp
	mov	ebp, esp
	push	ebx

; 145  : 	LPBITMAPINFOHEADER lpbi;					// Holds The Bitmap Header Information
; 146  :   char *pdata;
; 147  :   short tmpv, *psdata;
; 148  :   int status = 0;
; 149  :   int i,j,n;
; 150  : 
; 151  : 	// Grab Data From The AVI Stream
; 152  : 	lpbi = (LPBITMAPINFOHEADER)AVIStreamGetFrame(m->pgf, m->currframe);

	mov	ebx, DWORD PTR _m$[ebp]
	push	esi
	push	edi
	mov	eax, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR [ebx]
	push	eax
	push	ecx
	call	_AVIStreamGetFrame@8

; 153  :   //pdata = (char *)lpbi + sizeof(BITMAPINFOHEADER);
; 154  : 
; 155  : #if 0
; 156  :   printf("biSize:%d w:%d h:%d planes:%d bitcount:%d biClrUsed:%d Comp:%d\n",
; 157  :          lpbi->biSize,lpbi->biWidth,lpbi->biHeight,lpbi->biPlanes,
; 158  :          lpbi->biBitCount, lpbi->biClrUsed,lpbi->biCompression);
; 159  : #endif
; 160  : 
; 161  : 	// Pointer To Data Returned By AVIStreamGetFrame
; 162  :   // (Skip The Header Info To Get To The Data)
; 163  :   pdata = (char *)lpbi + lpbi->biSize + lpbi->biClrUsed * sizeof(RGBQUAD);

	mov	edx, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR [eax]
	lea	esi, DWORD PTR [ecx+edx*4]

; 164  : 
; 165  :   n = m->width*m->height*3;

	mov	ecx, DWORD PTR [ebx+8]
	imul	ecx, DWORD PTR [ebx+12]
	add	esi, eax
	lea	edx, DWORD PTR [ecx+ecx*2]

; 166  :   if (lpbi->biBitCount == 24) {

	mov	cx, WORD PTR [eax+14]
	cmp	cx, 24					; 00000018H
	mov	DWORD PTR _n$[ebp], edx
	jne	SHORT $L53027

; 167  :     memcpy(bmpdata,pdata,n);

	mov	eax, DWORD PTR _bmpdata$[ebp]
	mov	ecx, edx
	mov	edi, eax
	shr	ecx, 2
	rep movsd
	mov	ecx, edx
	and	ecx, 3
	rep movsb

; 168  :     // Swap The Red And Blue Bytes (GL Compatability)
; 169  :     FlipBGR2RGB(bmpdata, m->width*m->height);

	mov	ecx, DWORD PTR [ebx+8]
	imul	ecx, DWORD PTR [ebx+12]
	push	ecx
	push	eax
	call	_FlipBGR2RGB
	add	esp, 8

; 182  :       //bmpdata[i]   = (unsigned char)((tmpv>>8) & 0xf9);
; 183  :       //bmpdata[i+1] = (unsigned char)((tmpv>>3) & 0xfc);
; 184  :       //bmpdata[i+2] = (unsigned char)((tmpv<<3) & 0xf9);
; 185  : #else
; 186  :       bmpdata[i]   = (unsigned char)((tmpv>>10) & 0x1f)*8;
; 187  :       bmpdata[i+1] = (unsigned char)((tmpv>>5) & 0x1f)*8;
; 188  :       bmpdata[i+2] = (unsigned char)(tmpv & 0x1f)*8;
; 189  : #endif
; 190  :     }
; 191  :   }
; 192  : 
; 193  :   return status;

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx

; 194  : }

	pop	ebp
	ret	0
$L53027:

; 170  :   } else if (lpbi->biBitCount == 16) {

	cmp	cx, 16					; 00000010H
	jne	SHORT $L53154

; 171  :     if (lpbi->biCompression == BI_BITFIELDS) {

	cmp	DWORD PTR [eax+16], 3
	jne	SHORT $L53030

; 172  :       printf(" vavifunc warning: RGB565???, not supportted yet.");

	push	OFFSET FLAT:??_C@_0DC@FIIE@?5vavifunc?5warning?3?5RGB565?$DP?$DP?$DP?0?5no@ ; `string'
	call	_mexPrintf
	mov	edx, DWORD PTR _n$[ebp]
	add	esp, 4
$L53030:

; 173  :     }
; 174  :     psdata = (short *)pdata;
; 175  :     for (i = 0, j = 0; i < n; i+=3, j++) {

	test	edx, edx
	jle	SHORT $L53154
	mov	eax, DWORD PTR _bmpdata$[ebp]
	or	edi, -1
	sub	edi, eax
	lea	ecx, DWORD PTR [eax+1]
$L53033:

; 176  :       tmpv = psdata[j];

	mov	ax, WORD PTR [esi]
	add	ecx, 3

; 177  :       // RGB555
; 178  : #if 1
; 179  :       bmpdata[i]   = (unsigned char)((tmpv>>7) & 0xf9);

	mov	ebx, eax
	add	esi, 2
	sar	ebx, 7
	and	bl, 249					; 000000f9H
	mov	BYTE PTR [ecx-4], bl

; 180  :       bmpdata[i+1] = (unsigned char)((tmpv>>2) & 0xf9);

	mov	ebx, eax
	sar	ebx, 2
	and	bl, 249					; 000000f9H

; 181  :       bmpdata[i+2] = (unsigned char)((tmpv<<3) & 0xf9);

	shl	al, 3
	mov	BYTE PTR [ecx-3], bl
	mov	BYTE PTR [ecx-2], al
	lea	eax, DWORD PTR [edi+ecx]
	cmp	eax, edx
	jl	SHORT $L53033
$L53154:
	pop	edi
	pop	esi

; 182  :       //bmpdata[i]   = (unsigned char)((tmpv>>8) & 0xf9);
; 183  :       //bmpdata[i+1] = (unsigned char)((tmpv>>3) & 0xfc);
; 184  :       //bmpdata[i+2] = (unsigned char)((tmpv<<3) & 0xf9);
; 185  : #else
; 186  :       bmpdata[i]   = (unsigned char)((tmpv>>10) & 0x1f)*8;
; 187  :       bmpdata[i+1] = (unsigned char)((tmpv>>5) & 0x1f)*8;
; 188  :       bmpdata[i+2] = (unsigned char)(tmpv & 0x1f)*8;
; 189  : #endif
; 190  :     }
; 191  :   }
; 192  : 
; 193  :   return status;

	xor	eax, eax
	pop	ebx

; 194  : }

	pop	ebp
	ret	0
_GrabAVIFrame ENDP
_TEXT	ENDS
PUBLIC	_GrabAVIFrameDouble
; Function compile flags: /Ogt
;	COMDAT _GrabAVIFrameDouble
_TEXT	SEGMENT
_m$ = 8
_bmpdata$ = 12
_GrabAVIFrameDouble PROC NEAR				; COMDAT

; 199  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 200  : 	LPBITMAPINFOHEADER lpbi;					// Holds The Bitmap Header Information
; 201  :   unsigned char *pdata;
; 202  :   short tmpv, *psdata;
; 203  :   int status = 0;
; 204  :   int i, j, n;
; 205  : 
; 206  : 	// Grab Data From The AVI Stream
; 207  : 	lpbi = (LPBITMAPINFOHEADER)AVIStreamGetFrame(m->pgf, m->currframe);

	mov	esi, DWORD PTR _m$[ebp]
	push	edi
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	push	eax
	push	ecx
	call	_AVIStreamGetFrame@8

; 208  :   //pdata = (char *)lpbi + sizeof(BITMAPINFOHEADER);
; 209  : 
; 210  : #if 0
; 211  :   printf("biSize:%d w:%d h:%d planes:%d bitcount:%d biClrUsed:%d Comp:%d\n",
; 212  :          lpbi->biSize,lpbi->biWidth,lpbi->biHeight,lpbi->biPlanes,
; 213  :          lpbi->biBitCount, lpbi->biClrUsed,lpbi->biCompression);
; 214  : #endif
; 215  : 
; 216  : 	// Pointer To Data Returned By AVIStreamGetFrame
; 217  :   // (Skip The Header Info To Get To The Data)
; 218  :   pdata = (unsigned char *)lpbi + lpbi->biSize + lpbi->biClrUsed * sizeof(RGBQUAD);

	mov	edx, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR [eax]
	lea	edi, DWORD PTR [ecx+edx*4]

; 219  : 
; 220  :   if (lpbi->biBitCount == 24) {

	mov	cx, WORD PTR [eax+14]
	add	edi, eax
	cmp	cx, 24					; 00000018H
	jne	SHORT $L53055

; 221  :     n = m->height*m->width*3;

	mov	eax, DWORD PTR [esi+12]
	imul	eax, DWORD PTR [esi+8]
	lea	edx, DWORD PTR [eax+eax*2]

; 222  :     for (i = 0; i < n; i+=3) {

	test	edx, edx
	jle	$L53162
	mov	ecx, DWORD PTR _bmpdata$[ebp]
	or	esi, -1
	add	ecx, 16					; 00000010H
	lea	eax, DWORD PTR [edi+1]
	sub	esi, edi
	push	ebx
$L53056:

; 223  :       bmpdata[i]   = (double)pdata[i+2];

	xor	ebx, ebx
	add	ecx, 24					; 00000018H
	mov	bl, BYTE PTR [eax+1]
	add	eax, 3
	mov	DWORD PTR 12+[ebp], ebx

; 224  :       bmpdata[i+1] = (double)pdata[i+1];

	xor	ebx, ebx
	fild	DWORD PTR 12+[ebp]
	lea	edi, DWORD PTR [esi+eax]
	fstp	QWORD PTR [ecx-40]
	mov	bl, BYTE PTR [eax-3]
	mov	DWORD PTR 12+[ebp], ebx

; 225  :       bmpdata[i+2] = (double)pdata[i];

	xor	ebx, ebx
	fild	DWORD PTR 12+[ebp]
	cmp	edi, edx
	fstp	QWORD PTR [ecx-32]
	mov	bl, BYTE PTR [eax-4]
	mov	DWORD PTR 12+[ebp], ebx
	fild	DWORD PTR 12+[ebp]
	fstp	QWORD PTR [ecx-24]
	jl	SHORT $L53056
	pop	ebx
	pop	edi

; 239  :     }
; 240  :   }
; 241  : 
; 242  :   return status;

	xor	eax, eax
	pop	esi

; 243  : }

	pop	ebp
	ret	0
$L53055:

; 226  :     }
; 227  :   } else if (lpbi->biBitCount == 16) {

	cmp	cx, 16					; 00000010H
	jne	$L53162

; 228  :     if (lpbi->biCompression == BI_BITFIELDS) {

	cmp	DWORD PTR [eax+16], 3
	jne	SHORT $L53064

; 229  :       printf(" vavifunc warning: RGB565???, not supportted yet.");

	push	OFFSET FLAT:??_C@_0DC@FIIE@?5vavifunc?5warning?3?5RGB565?$DP?$DP?$DP?0?5no@ ; `string'
	call	_mexPrintf
	add	esp, 4
$L53064:

; 230  :     }
; 231  :     // RGB555
; 232  :     psdata = (short *)pdata;
; 233  :     n = m->height*m->width*3;

	mov	eax, DWORD PTR [esi+12]
	imul	eax, DWORD PTR [esi+8]
	lea	eax, DWORD PTR [eax+eax*2]

; 234  :     for (i = 0, j = 0; i < n; i+=3, j++) {

	test	eax, eax
	jle	SHORT $L53162
	mov	edx, DWORD PTR _bmpdata$[ebp]
	lea	ecx, DWORD PTR [edx+16]
	lea	edx, DWORD PTR [eax-1]
	mov	eax, -1431655765			; aaaaaaabH
	mul	edx
	mov	esi, edx
	shr	esi, 1
	inc	esi
$L53066:

; 235  :         tmpv = psdata[j];

	mov	ax, WORD PTR [edi]
	add	ecx, 24					; 00000018H

; 236  :         bmpdata[i]   = (double)((unsigned char)((tmpv>>7) & 0xf9));

	mov	edx, eax
	add	edi, 2
	sar	edx, 7
	and	dl, 249					; 000000f9H
	and	edx, 255				; 000000ffH
	mov	DWORD PTR 12+[ebp], edx

; 237  :         bmpdata[i+1] = (double)((unsigned char)((tmpv>>2) & 0xf9));

	mov	edx, eax
	fild	DWORD PTR 12+[ebp]
	sar	edx, 2
	and	dl, 249					; 000000f9H
	fstp	QWORD PTR [ecx-40]
	and	edx, 255				; 000000ffH
	mov	DWORD PTR 12+[ebp], edx
	fild	DWORD PTR 12+[ebp]

; 238  :         bmpdata[i+2] = (double)((unsigned char)((tmpv<<3) & 0xf9));

	shl	al, 3
	and	eax, 255				; 000000ffH
	dec	esi
	fstp	QWORD PTR [ecx-32]
	mov	DWORD PTR 12+[ebp], eax
	fild	DWORD PTR 12+[ebp]
	fstp	QWORD PTR [ecx-24]
	jne	SHORT $L53066
$L53162:
	pop	edi

; 239  :     }
; 240  :   }
; 241  : 
; 242  :   return status;

	xor	eax, eax
	pop	esi

; 243  : }

	pop	ebp
	ret	0
_GrabAVIFrameDouble ENDP
_TEXT	ENDS
PUBLIC	_GrabAVIFrameMatlab
; Function compile flags: /Ogt
;	COMDAT _GrabAVIFrameMatlab
_TEXT	SEGMENT
_m$ = 8
_bmpdata$ = 12
_pdata$ = -12
_j$ = -8
_k$ = -20
_c$ = 8
_h$ = -4
_GrabAVIFrameMatlab PROC NEAR				; COMDAT

; 248  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi

; 249  : 	LPBITMAPINFOHEADER lpbi;					// Holds The Bitmap Header Information
; 250  :   unsigned char *pdata;
; 251  :   short tmpv, *psdata;
; 252  :   int status = 0;
; 253  :   int i, j, k, c, w, h;
; 254  : 
; 255  : 	// Grab Data From The AVI Stream
; 256  : 	lpbi = (LPBITMAPINFOHEADER)AVIStreamGetFrame(m->pgf, m->currframe);

	mov	esi, DWORD PTR _m$[ebp]
	push	edi
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	push	eax
	push	ecx
	call	_AVIStreamGetFrame@8

; 257  :   //pdata = (char *)lpbi + sizeof(BITMAPINFOHEADER);
; 258  : 
; 259  : #if 0
; 260  :   printf("biSize:%d w:%d h:%d planes:%d bitcount:%d biClrUsed:%d Comp:%d\n",
; 261  :          lpbi->biSize,lpbi->biWidth,lpbi->biHeight,lpbi->biPlanes,
; 262  :          lpbi->biBitCount, lpbi->biClrUsed,lpbi->biCompression);
; 263  : #endif
; 264  : 
; 265  : 	// Pointer To Data Returned By AVIStreamGetFrame
; 266  :   // (Skip The Header Info To Get To The Data)
; 267  :   pdata = (unsigned char *)lpbi + lpbi->biSize + lpbi->biClrUsed * sizeof(RGBQUAD);

	mov	edx, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR [eax]
	lea	ecx, DWORD PTR [ecx+edx*4]
	add	ecx, eax
	mov	DWORD PTR _pdata$[ebp], ecx

; 268  : 
; 269  :   // Matlab stores image as a three-dimensional
; 270  :   // (m-by-n-by-3) array of floating-point
; 271  :   // values in the range [0, 1]...
; 272  :   if (lpbi->biBitCount == 24) {

	mov	cx, WORD PTR [eax+14]
	cmp	cx, 24					; 00000018H
	jne	$L53094
	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [esi+8]

; 273  : #if 1
; 274  : # if 1
; 275  :     for (c = 0; c < 3; c++) {

	mov	DWORD PTR _c$[ebp], 0
	mov	DWORD PTR -8+[ebp], 2
$L53095:

; 276  :       k = m->height*m->width*c;

	mov	ebx, ecx

; 277  :       j = 2 - c;  // need to flip Red and Blue

	mov	edi, DWORD PTR -8+[ebp]
	imul	ebx, eax
	imul	ebx, DWORD PTR _c$[ebp]

; 278  :       for (h = 0; h < m->height; h++) {

	test	eax, eax
	mov	DWORD PTR _k$[ebp], ebx
	mov	DWORD PTR _h$[ebp], 0
	jle	SHORT $L53096
$L53098:

; 279  :         i = m->height - h - 1 + k;

	mov	edx, DWORD PTR _h$[ebp]
	sub	eax, edx

; 280  :         for (w = 0; w < m->width; w++) {

	xor	edx, edx
	test	ecx, ecx
	lea	eax, DWORD PTR [eax+ebx-1]
	jle	SHORT $L53099
$L53101:

; 281  :           bmpdata[i] = (double)pdata[j];

	mov	ebx, DWORD PTR _pdata$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [edi+ebx]

; 282  :           j += 3;

	add	edi, 3
	mov	DWORD PTR -16+[ebp], ecx
	mov	ecx, DWORD PTR _bmpdata$[ebp]
	fild	DWORD PTR -16+[ebp]
	fstp	QWORD PTR [ecx+eax*8]

; 283  :           i += m->height;

	mov	ebx, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [esi+8]
	add	eax, ebx
	inc	edx
	cmp	edx, ecx
	jl	SHORT $L53101

; 280  :         for (w = 0; w < m->width; w++) {

	mov	ebx, DWORD PTR _k$[ebp]
$L53099:

; 278  :       for (h = 0; h < m->height; h++) {

	mov	edx, DWORD PTR _h$[ebp]
	mov	eax, DWORD PTR [esi+12]
	inc	edx
	cmp	edx, eax
	mov	DWORD PTR _h$[ebp], edx
	jl	SHORT $L53098
$L53096:

; 273  : #if 1
; 274  : # if 1
; 275  :     for (c = 0; c < 3; c++) {

	mov	edx, DWORD PTR _c$[ebp]
	inc	edx
	mov	DWORD PTR _c$[ebp], edx
	mov	edx, DWORD PTR -8+[ebp]
	dec	edx
	cmp	edx, -1
	mov	DWORD PTR -8+[ebp], edx
	jg	SHORT $L53095
	pop	edi
	pop	esi

; 325  :       }
; 326  :     }
; 327  :   }
; 328  : 
; 329  :   return status;

	xor	eax, eax
	pop	ebx

; 330  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$L53094:

; 284  :         }
; 285  :       }
; 286  :     }
; 287  : # else
; 288  :     k = m->height*m->width*3;
; 289  :     for (h = 0; h < k; h++)  bmpdata[h] = (double)pdata[h];
; 290  : # endif
; 291  : #else
; 292  :     j = 0;
; 293  :     c = m->height*m->width;
; 294  :     k = c*2;
; 295  :     for (h = 0; h < m->height; h++) {
; 296  :       i = m->height - h - 1;
; 297  :       for (w = 0; w < m->width; w++) {
; 298  :         // need to flip RED and BLUE
; 299  :         bmpdata[i+k] = (double)pdata[j];
; 300  :         bmpdata[i+c] = (double)pdata[j+1];
; 301  :         bmpdata[i]   = (double)pdata[j+2];
; 302  :         j += 3;
; 303  :         i += m->height;
; 304  :       }
; 305  :     }
; 306  : #endif
; 307  :   } else if (lpbi->biBitCount == 16) {

	cmp	cx, 16					; 00000010H
	jne	$L53175

; 308  :     if (lpbi->biCompression == BI_BITFIELDS) {

	cmp	DWORD PTR [eax+16], 3
	jne	SHORT $L53107

; 309  :       printf(" vavifunc warning: RGB565???, not supportted yet.");

	push	OFFSET FLAT:??_C@_0DC@FIIE@?5vavifunc?5warning?3?5RGB565?$DP?$DP?$DP?0?5no@ ; `string'
	call	_mexPrintf
	add	esp, 4
$L53107:

; 310  :     }
; 311  :     // RGB555
; 312  :     psdata = (short *)pdata;
; 313  :     j = 0;
; 314  :     c = m->height*m->width;

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, eax
	xor	ebx, ebx
	imul	edx, ecx

; 315  :     k = c*2;
; 316  :     for (h = 0; h < m->height; h++) {

	cmp	ecx, ebx
	mov	DWORD PTR _j$[ebp], ebx
	mov	DWORD PTR _c$[ebp], edx
	mov	DWORD PTR _h$[ebp], ebx
	jle	$L53175
	mov	edi, DWORD PTR _bmpdata$[ebp]
$L53109:

; 317  :       i = m->height - h - 1;

	sub	ecx, ebx

; 318  :       for (w = 0; w < m->width; w++) {

	xor	edx, edx
	dec	ecx
	test	eax, eax
	jle	SHORT $L53110
$L53112:

; 319  :         tmpv = psdata[j];

	mov	eax, DWORD PTR _pdata$[ebp]
	mov	ebx, DWORD PTR _j$[ebp]
	mov	ax, WORD PTR [eax+ebx*2]

; 320  :         bmpdata[i]   = (double)((unsigned char)((tmpv>>7) & 0xf9));

	mov	ebx, eax
	sar	ebx, 7
	and	bl, 249					; 000000f9H
	and	ebx, 255				; 000000ffH
	mov	DWORD PTR 12+[ebp], ebx

; 321  :         bmpdata[i+c] = (double)((unsigned char)((tmpv>>2) & 0xf9));

	mov	ebx, eax
	fild	DWORD PTR 12+[ebp]
	sar	ebx, 2
	and	bl, 249					; 000000f9H
	fstp	QWORD PTR [edi+ecx*8]
	and	ebx, 255				; 000000ffH
	mov	DWORD PTR 12+[ebp], ebx
	mov	ebx, DWORD PTR _c$[ebp]
	fild	DWORD PTR 12+[ebp]

; 322  :         bmpdata[i+k] = (double)((unsigned char)((tmpv<<3) & 0xf9));

	shl	al, 3
	add	ebx, ecx
	and	eax, 255				; 000000ffH
	mov	DWORD PTR 12+[ebp], eax
	mov	eax, DWORD PTR _c$[ebp]
	fstp	QWORD PTR [edi+ebx*8]
	fild	DWORD PTR 12+[ebp]
	lea	eax, DWORD PTR [ecx+eax*2]
	fstp	QWORD PTR [edi+eax*8]

; 323  :         j ++;

	mov	eax, DWORD PTR _j$[ebp]

; 324  :         i += m->height;

	mov	ebx, DWORD PTR [esi+12]
	inc	eax
	add	ecx, ebx
	mov	DWORD PTR _j$[ebp], eax
	mov	eax, DWORD PTR [esi+8]
	inc	edx
	cmp	edx, eax
	jl	SHORT $L53112

; 318  :       for (w = 0; w < m->width; w++) {

	mov	ebx, DWORD PTR _h$[ebp]
$L53110:

; 315  :     k = c*2;
; 316  :     for (h = 0; h < m->height; h++) {

	mov	ecx, DWORD PTR [esi+12]
	inc	ebx
	cmp	ebx, ecx
	mov	DWORD PTR _h$[ebp], ebx
	jl	SHORT $L53109
$L53175:
	pop	edi
	pop	esi

; 325  :       }
; 326  :     }
; 327  :   }
; 328  : 
; 329  :   return status;

	xor	eax, eax
	pop	ebx

; 330  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_GrabAVIFrameMatlab ENDP
_TEXT	ENDS
PUBLIC	_CloseAVI
EXTRN	_AVIStreamGetFrameClose@4:NEAR
; Function compile flags: /Ogt
;	COMDAT _CloseAVI
_TEXT	SEGMENT
_m$ = 8
_CloseAVI PROC NEAR					; COMDAT

; 335  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 336  : 	AVIStreamGetFrameClose(m->pgf); // Deallocates The GetFrame Resources

	mov	esi, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR [esi]
	push	eax
	call	_AVIStreamGetFrameClose@4

; 337  : 	AVIStreamRelease(m->pavi);      // Release The Stream

	mov	ecx, DWORD PTR [esi+164]
	push	ecx
	call	_AVIStreamRelease@4
	pop	esi

; 338  : }

	pop	ebp
	ret	0
_CloseAVI ENDP
_TEXT	ENDS
END
